#include "defs.h"
/*  The banner used here should be replaced with an #ident directive    */
/*  if the target C compiler supports #ident directives.                */
/*                                                                      */
/*  If the skeleton is changed, the banner should be changed so that    */
/*  the altered version can easily be distinguished from the original.  */

char *banner[] =
{
    "#line 8 \"/home/dassat/github/cppparser/third_party/btyacc_tp/btyacc/btyaccpa.ske\"",
    "",
    "/*",
    "** @(#)btyaccpar, based on byacc 1.8 (Berkeley)",
    "*/",
    "#define YYBTYACC 1",
    "",
    "#include <stdio.h>",
    "#include <stdlib.h>",
    "#include <string.h>",
    "",
    "typedef int Yshort;",
    "",
    0
};

char *tables[] =
{
    "#line 21 \"/home/dassat/github/cppparser/third_party/btyacc_tp/btyacc/btyaccpa.ske\"",
    "",
    "#ifdef __cplusplus",
    "#define _C_ \"C\"",
    "#else",
    "#define _C_",
    "#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L",
    "#define inline",
    "#endif /* C99 */",
    "#endif /* C++ */",
    "",
    "extern _C_ Yshort yylhs[];",
    "extern _C_ Yshort yylen[];",
    "extern _C_ Yshort yydefred[];",
    "extern _C_ Yshort yydgoto[];",
    "extern _C_ Yshort yysindex[];",
    "extern _C_ Yshort yyrindex[];",
    "extern _C_ Yshort yycindex[];",
    "extern _C_ Yshort yygindex[];",
    "extern _C_ Yshort yytable[];",
    "extern _C_ Yshort yycheck[];",
    "extern _C_ Yshort yyctable[];",
    "extern _C_ Yshort yyastable[];",
    "extern _C_ Yshort yyttable[];",
    "",
    "#if YYDEBUG",
    "extern _C_ char *yyname[];",
    "extern _C_ char *yyrule[];",
    "#endif",
    "",
    0
};

char *header[] =
{
    "#line 51 \"/home/dassat/github/cppparser/third_party/btyacc_tp/btyacc/btyaccpa.ske\"",
    "",
    "/*",
    "** YYPOSN is user-defined text position type.",
    "*/",
    "#ifdef YYPOSN",
    "#ifdef YYREDUCEPOSNFUNC",
    "#define YYCALLREDUCEPOSN(e)   \\",
    "\tif(reduce_posn) {     \\",
    "\t  YYREDUCEPOSNFUNC(yyps->pos, &(yyps->psp)[1-yym], &(yyps->vsp)[1-yym], \\",
    "\t\t\t   yym, yyps->psp - yyps->ps, yychar, yyposn, e);       \\",
    "\t  reduce_posn = 0;    \\",
    "\t}",
    "",
    "#ifndef YYCALLREDUCEPOSNARG",
    "#define YYCALLREDUCEPOSNARG yyps->val",
    "#endif",
    "",
    "",
    "#define YYPOSNARG(n) ((yyps->psp)[1-yym+(n)-1])",
    "#define YYPOSNOUT    (yyps->pos)",
    "#endif /* YYREDUCEPOSNFUNC */",
    "#endif /* YYPOSN */",
    "",
    "/* If delete function is not defined by the user, do not deletions. */",
    "#ifndef YYDELETEVAL",
    "#define YYDELETEVAL(v, x) ",
    "#endif",
    "",
    "/* If delete function is not defined by the user, do not deletions. */",
    "#ifndef YYDELETEPOSN",
    "#define YYDELETEPOSN(v, x) ",
    "#endif",
    "",
    "#define yyclearin (yychar=(-1))",
    "",
    "#define yyerrok (yyps->errflag=0)",
    "",
    "#ifndef YYSTACKGROWTH",
    "#define YYSTACKGROWTH 16",
    "#endif",
    "",
    "#ifndef YYDEFSTACKSIZE",
    "#define YYDEFSTACKSIZE 12",
    "#endif",
    "",
    "#ifdef YYDEBUG",
    "int yydebug;",
    "#endif",
    "",
    "extern void yyerror(const char *, ...);",
    "",
    "int yynerrs;",
    "",
    "/* These value/posn are taken from the lexer */",
    "YYSTYPE yylval;",
    "#ifdef YYPOSN",
    "YYPOSN  yyposn;",
    "#endif /* YYPOSN */",
    "",
    "/* These value/posn of the root non-terminal are returned to the caller */",
    "YYSTYPE yyretlval;",
    "#ifdef YYPOSN",
    "YYPOSN  yyretposn;",
    "#endif /* YYPOSN */",
    "",
    "#define YYABORT  goto yyabort",
    "#define YYACCEPT goto yyaccept",
    "#define YYERROR  goto yyerrlab",
    "#define YYERROR_QUIET  goto yyerrquiet",
    "#define YYVALID         do { if (yyps->save)          goto yyvalid; } while(0)",
    "#define YYVALID_NESTED  do { if (yyps->save && \\",
    "                                 yyps->save->save==0) goto yyvalid; } while(0)",
    "",
    "struct yyparsestate {",
    "  struct yyparsestate *save;        /* Previously saved parser state */",
    "  int           state;",
    "  int           errflag;",
    "  Yshort       *ss;          /* state stack base */",
    "  Yshort       *ssp;         /* state stack pointer */",
    "  YYSTYPE      *vs;          /* values stack base */",
    "  YYSTYPE      *vsp;         /* value stack pointer */",
    "  YYSTYPE       val;         /* value as returned by actions */",
    "#ifdef YYPOSN",
    "  YYPOSN       *ps;          /* position stack base */",
    "  YYPOSN       *psp;         /* position stack pointer */",
    "  YYPOSN        pos;         /* position as returned by universal action */",
    "#endif /* YYPOSN */",
    "  int           lexeme;      /* index of the conflict lexeme in the lexical queue */",
    "  unsigned int  stacksize;   /* current maximum stack size */",
    "  Yshort        ctry;        /* index in yyctable[] for this conflict */",
    "};",
    "",
    "/* Current parser state */",
    "static struct yyparsestate *yyps=0;",
    "",
    "/* yypath!=NULL: do the full parse, starting at *yypath parser state. */",
    "static struct yyparsestate *yypath=0;",
    "",
    "/* Base of the lexical value queue */",
    "static YYSTYPE *yylvals=0;",
    "",
    "/* Current posistion at lexical value queue */",
    "static YYSTYPE *yylvp=0;",
    "",
    "/* End position of lexical value queue */",
    "static YYSTYPE *yylve=0;",
    "",
    "/* The last allocated position at the lexical value queue */",
    "static YYSTYPE *yylvlim=0;",
    "",
    "#ifdef YYPOSN",
    "/* Base of the lexical position queue */",
    "static YYPOSN *yylpsns=0;",
    "",
    "/* Current posistion at lexical position queue */",
    "static YYPOSN *yylpp=0;",
    "",
    "/* End position of lexical position queue */",
    "static YYPOSN *yylpe=0;",
    "",
    "/* The last allocated position at the lexical position queue */",
    "static YYPOSN *yylplim=0;",
    "#endif /* YYPOSN */",
    "",
    "/* Current position at lexical token queue */",
    "static Yshort *yylexp=0;",
    "",
    "static Yshort *yylexemes=0;",
    "",
    "/*",
    "** For use in generated program",
    "*/",
    "#define yytrial (yyps->save)",
    "#define yyvsp   (yyps->vsp)",
    "#define yyval   (yyps->val)",
    "#define yypsp   (yyps->psp)",
    "#define yypos   (yyps->pos)",
    "#define yydepth (yyps->ssp - yyps->ss)",
    "",
    "",
    "/*",
    "** Local prototypes.",
    "*/",
    "int yyparse(void);",
    "int yylex(void);",
    "",
    "static void YYSCopy(YYSTYPE *to, YYSTYPE *from, int size) {",
    "  int i;                             ",
    "  for (i = size-1; i >= 0; i--)",
    "    to[i] = from[i];",
    "}",
    "",
    "#ifdef YYPOSN",
    "static void YYPCopy(YYPOSN *to, YYPOSN *from, int size) {",
    "  int i;                             ",
    "  for (i = size-1; i >= 0; i--)",
    "    to[i] = from[i];",
    "}",
    "#endif /* YYPOSN */",
    "",
    "static int yyexpand() {",
    "  int p = yylvp-yylvals;",
    "  int s = yylvlim-yylvals;",
    "  s += YYSTACKGROWTH;",
    "#ifdef __cplusplus",
    "  Yshort  *tl = yylexemes; ",
    "  yylexemes = new Yshort[s];",
    "  memcpy(yylexemes, tl, (s-YYSTACKGROWTH)*sizeof(Yshort));",
    "  delete[] tl;",
    "  YYSTYPE *tv = yylvals;",
    "  yylvals = new YYSTYPE[s];",
    "  YYSCopy(yylvals, tv, s-YYSTACKGROWTH);",
    "  delete[] tv;",
    "#ifdef YYPOSN",
    "  YYPOSN  *tp = yylpsns;",
    "  yylpsns = new YYPOSN[s];",
    "  YYPCopy(yylpsns, tp, s-YYSTACKGROWTH);",
    "  delete[] tp;",
    "#endif /* YYPOSN */",
    "#else",
    "  yylexemes = realloc(yylexemes, sizeof(Yshort) * s);",
    "  yylvals = realloc(yylvals, sizeof(YYSTYPE) * s);",
    "#ifdef YYPOSN",
    "  yylpsns = realloc(yylpsns, sizeof(YYPOSN) * s);",
    "#endif /* YYPOSN */",
    "#endif",
    "  yylexp = yylexemes + p;",
    "  yylvp = yylve = yylvals + p;",
    "  yylvlim = yylvals + s;",
    "#ifdef YYPOSN",
    "  yylpp = yylpe = yylpsns + p;",
    "  yylplim = yylpsns + s;",
    "#endif /* YYPOSN */",
    "  return 0;",
    "}",
    "",
    "static int YYLex1() {",
    "  if(yylvp<yylve) {",
    "    yylval = *yylvp++;",
    "#ifdef YYPOSN",
    "    yyposn = *yylpp++;",
    "#endif /* YYPOSN */",
    "    return *yylexp++;",
    "  } else {",
    "    if(yyps->save) {",
    "      if(yylvp==yylvlim) {",
    "\tyyexpand();",
    "      }",
    "      *yylexp = yylex();",
    "      *yylvp++ = yylval;",
    "      yylve++;",
    "#ifdef YYPOSN",
    "      *yylpp++ = yyposn;",
    "      yylpe++;",
    "#endif /* YYPOSN */",
    "      return *yylexp++;",
    "    } else {",
    "      return yylex();",
    "    }",
    "  }",
    "}",
    "",
    "static void YYMoreStack(struct yyparsestate *yyps) {",
    "  int p = yyps->ssp - yyps->ss;                               ",
    "#ifdef __cplusplus",
    "  Yshort  *tss = yyps->ss;",
    "  yyps->ss = new Yshort [yyps->stacksize + YYSTACKGROWTH];   ",
    "  memcpy(yyps->ss, tss, yyps->stacksize * sizeof(Yshort));  ",
    "  delete[] tss;",
    "  YYSTYPE *tvs = yyps->vs;",
    "  yyps->vs = new YYSTYPE[yyps->stacksize + YYSTACKGROWTH];  ",
    "  YYSCopy(yyps->vs, tvs, yyps->stacksize);                  ",
    "  delete[] tvs;",
    "#ifdef YYPOSN",
    "  YYPOSN  *tps = yyps->ps;",
    "  yyps->ps = new YYPOSN [yyps->stacksize + YYSTACKGROWTH];  ",
    "  YYPCopy(yyps->ps, tps, yyps->stacksize);                  ",
    "  delete[] tps;",
    "#endif /* YYPOSN */",
    "  yyps->stacksize += YYSTACKGROWTH;                           ",
    "#else",
    "  yyps->stacksize += YYSTACKGROWTH;                           ",
    "  yyps->ss = realloc(yyps->ss, sizeof(Yshort ) * yyps->stacksize);   ",
    "  yyps->vs = realloc(yyps->vs, sizeof(YYSTYPE) * yyps->stacksize);  ",
    "#ifdef YYPOSN",
    "  yyps->ps = realloc(yyps->ps, sizeof(YYPOSN ) * yyps->stacksize);  ",
    "#endif /* YYPOSN */",
    "#endif",
    "  yyps->ssp = yyps->ss + p;                                   ",
    "  yyps->vsp = yyps->vs + p;                                   ",
    "#ifdef YYPOSN",
    "  yyps->psp = yyps->ps + p;                                   ",
    "#endif /* YYPOSN */",
    "}",
    "",
    "static struct yyparsestate *YYNewState(int size) {",
    "#ifdef __cplusplus",
    "  yyparsestate *p = new yyparsestate;",
    "  p->ss = new Yshort [size + 4];",
    "  p->vs = new YYSTYPE[size + 4];",
    "#ifdef YYPOSN",
    "  p->ps = new YYPOSN [size + 4];",
    "#endif /* YYPOSN */",
    "#else",
    "  struct yyparsestate *p = malloc(sizeof(struct yyparsestate));",
    "  p->ss = malloc(sizeof(Yshort ) * (size + 4));",
    "  p->vs = malloc(sizeof(YYSTYPE) * (size + 4));",
    "#ifdef YYPOSN",
    "  p->ps = malloc(sizeof(YYPOSN ) * (size + 4));",
    "#endif /* YYPOSN */",
    "#endif",
    "  p->stacksize = size+4;",
    "  memset(&p->vs[0], 0, (size+4)*sizeof(YYSTYPE));",
    "#ifdef YYPOSN",
    "  memset(&p->ps[0], 0, (size+4)*sizeof(YYPOSN));",
    "#endif /* YYPOSN */",
    "  return p;",
    "}",
    "",
    "static void YYFreeState(struct yyparsestate *p) {",
    "#ifdef __cplusplus",
    "  delete[] p->ss;",
    "  delete[] p->vs;",
    "#ifdef YYPOSN",
    "  delete[] p->ps;",
    "#endif /* YYPOSN */",
    "  delete p;",
    "#else",
    "  free(p->ss);",
    "  free(p->vs);",
    "#ifdef YYPOSN",
    "  free(p->ps);",
    "#endif /* YYPOSN */",
    "  free(p);",
    "#endif",
    "}",
    "",
    0
};

char *body[] =
{
    "#line 349 \"/home/dassat/github/cppparser/third_party/btyacc_tp/btyacc/btyaccpa.ske\"",
    "",
    "/*",
    "** Parser function",
    "*/",
    "int yyparse() {",
    "  int yym, yyn, yystate, yychar, yynewerrflag;",
    "  struct yyparsestate *yyerrctx = NULL;",
    "#ifdef YYREDUCEPOSNFUNC",
    "  int reduce_posn;",
    "#endif /* YYREDUCEPOSNFUNC */",
    "",
    "#if YYDEBUG",
    "  char *yys;",
    "  ",
    "  if ((yys = getenv(\"YYDEBUG\"))) {",
    "    yyn = *yys;",
    "    if (yyn >= '0' && yyn <= '9')",
    "      yydebug = yyn - '0'; ",
    "  }",
    "#endif",
    "  ",
    "  yyps = YYNewState(YYDEFSTACKSIZE);",
    "  yyps->save = 0;",
    "  yynerrs = 0;",
    "  yyps->errflag = 0;",
    "  yychar = (-1);",
    "  ",
    "  yyps->ssp = yyps->ss;",
    "  yyps->vsp = yyps->vs;",
    "#ifdef YYPOSN",
    "  yyps->psp = yyps->ps;",
    "#endif /* YYPOSN */",
    "  *(yyps->ssp) = yystate = 0;",
    "  ",
    "",
    "  /*",
    "  ** Main parsing loop",
    "  */",
    " yyloop:",
    "  if ((yyn = yydefred[yystate])) {",
    "    goto yyreduce;",
    "  }",
    "",
    "  /*",
    "  ** Read one token",
    "  */",
    "  if (yychar < 0) {",
    "    if ((yychar = YYLex1()) < 0) yychar = 0;",
    "#if YYDEBUG",
    "    if (yydebug) {",
    "      yys = 0;",
    "      if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "      if (!yys) yys = \"illegal-symbol\";",
    "      printf(\"yydebug[%d,%d]: state %d, reading %d (%s)\", ",
    "\t     (int)yydepth, yytrial!=0, yystate, yychar, yys);",
    "#ifdef YYDBPR",
    "      printf(\"<\");",
    "      YYDBPR(yylval);",
    "      printf(\">\");",
    "#endif",
    "      printf(\"\\n\"); ",
    "    }",
    "#endif",
    "  }",
    "",
    "  /*",
    "  ** Do we have a conflict?",
    "  */",
    "  if ((yyn = yycindex[yystate]) &&",
    "      (yyn += yychar) >= 0 &&",
    "      yyn <= YYTABLESIZE &&",
    "      yycheck[yyn] == yychar) {",
    "    int ctry;",
    "",
    "    if (yypath) {",
    "#if YYDEBUG",
    "      if (yydebug) {",
    "        printf(\"yydebug[%d,%d]: CONFLICT in state %d: following successful \"",
    "\t       \"trial parse\\n\", (int)yydepth, yytrial!=0, yystate);",
    "      }",
    "#endif",
    "      /* Switch to the next conflict context */",
    "      struct yyparsestate *save = yypath;",
    "      yypath = save->save;",
    "      ctry = save->ctry;",
    "      if (save->state != yystate) ",
    "        goto yyabort;",
    "      YYFreeState(save); ",
    "",
    "    } else {",
    "",
    "#if YYDEBUG",
    "      if (yydebug) {",
    "        printf(\"yydebug[%d,%d]: CONFLICT in state %d. \", ",
    "\t       (int)yydepth, yytrial!=0, yystate);",
    "        if(yyps->save) {",
    "          printf(\"ALREADY in conflict. Continue trial parse.\");",
    "        } else {",
    "          printf(\"Start trial parse.\");",
    "        }",
    "        printf(\"\\n\");",
    "      }",
    "#endif",
    "      struct yyparsestate *save = YYNewState(yyps->ssp - yyps->ss);",
    "      save->save    = yyps->save;",
    "      save->state   = yystate;",
    "      save->errflag = yyps->errflag;",
    "      save->ssp     = save->ss + (yyps->ssp - yyps->ss);",
    "      save->vsp     = save->vs + (yyps->vsp - yyps->vs);",
    "      memcpy (save->ss, yyps->ss, (yyps->ssp - yyps->ss + 1)*sizeof(Yshort));",
    "      YYSCopy(save->vs, yyps->vs, (yyps->ssp - yyps->ss + 1));",
    "#ifdef YYPOSN",
    "      save->psp     = save->ps + (yyps->psp - yyps->ps);",
    "      YYPCopy(save->ps, yyps->ps, (yyps->ssp - yyps->ss + 1));",
    "#endif /* YYPOSN */",
    "      ctry = yytable[yyn];",
    "      if (yyctable[ctry] == -1) {",
    "#if YYDEBUG",
    "        if (yydebug && yychar >= 0)",
    "          printf(\"yydebug[%d]: backtracking 1 token\\n\", ",
    "\t\t yytrial!=0);",
    "#endif",
    "        ctry++; ",
    "      }",
    "      save->ctry = ctry;",
    "      if (!yyps->save) {",
    "        /* If this is a first conflict in the stack, start saving lexemes */",
    "        if (!yylexemes) {",
    "#ifdef __cplusplus",
    "          yylexemes = new Yshort[YYSTACKGROWTH];",
    "          yylvals = new YYSTYPE[YYSTACKGROWTH];",
    "#ifdef YYPOSN",
    "          yylpsns = new YYPOSN[YYSTACKGROWTH];",
    "#endif /* YYPOSN */",
    "#else",
    "          yylexemes = malloc(sizeof(Yshort) * YYSTACKGROWTH);",
    "          yylvals = malloc(sizeof(YYSTYPE) * YYSTACKGROWTH);",
    "#ifdef YYPOSN",
    "          yylpsns = malloc(sizeof(YYPOSN) * YYSTACKGROWTH);",
    "#endif /* YYPOSN */",
    "#endif",
    "          yylvlim = yylvals + YYSTACKGROWTH; ",
    "#ifdef YYPOSN",
    "          yylplim = yylpsns + YYSTACKGROWTH; ",
    "#endif /* YYPOSN */",
    "        }",
    "        if (yylvp == yylve) {",
    "          yylvp = yylve = yylvals;",
    "#ifdef YYPOSN",
    "\t  yylpp = yylpe = yylpsns;",
    "#endif /* YYPOSN */",
    "          yylexp = yylexemes;",
    "          if (yychar >= 0) {",
    "            *yylve++ = yylval;",
    "#ifdef YYPOSN",
    "            *yylpe++ = yyposn;",
    "#endif /* YYPOSN */",
    "            *yylexp = yychar;",
    "            yychar = -1; ",
    "          } ",
    "        } ",
    "      }",
    "      if (yychar >= 0) {",
    "        yylvp--;",
    "#ifdef YYPOSN",
    "\tyylpp--;",
    "#endif /* YYPOSN */",
    "\tyylexp--;",
    "        yychar = -1; ",
    "      }",
    "      save->lexeme = yylvp - yylvals;",
    "      yyps->save = save; ",
    "    }",
    "    if (yytable[yyn] == ctry) {",
    "#if YYDEBUG",
    "      if (yydebug)",
    "        printf(\"yydebug[%d,%d]: state %d, shifting to state %d\\n\",",
    "               (int)yydepth, yytrial!=0, yystate, yyctable[ctry]);",
    "#endif",
    "      if (yychar < 0) {",
    "        yylvp++;",
    "#ifdef YYPOSN",
    "\tyylpp++;",
    "#endif /* YYPOSN */",
    "\tyylexp++;",
    "      }",
    "      yychar = -1;",
    "      if (yyps->errflag > 0) --yyps->errflag;",
    "      yystate = yyctable[ctry];",
    "      goto yyshift; ",
    "    } else {",
    "      yyn = yyctable[ctry];",
    "      goto yyreduce; ",
    "    } ",
    "  }",
    "",
    "  /*",
    "  ** Is action a shift?",
    "  */",
    "  if ((yyn = yysindex[yystate]) &&",
    "      (yyn += yychar) >= 0 &&",
    "      yyn <= YYTABLESIZE &&",
    "      yycheck[yyn] == yychar) {",
    "#if YYDEBUG",
    "    if (yydebug)",
    "      printf(\"yydebug[%d,%d]: state %d, shifting to state %d\\n\",",
    "             (int)yydepth, yytrial!=0, yystate, yytable[yyn]);",
    "#endif",
    "    yychar = (-1);",
    "    if (yyps->errflag > 0)  --yyps->errflag;",
    "    yystate = yytable[yyn];",
    "  yyshift:",
    "    if (yyps->ssp >= yyps->ss + yyps->stacksize - 1) {",
    "      YYMoreStack(yyps);",
    "    }",
    "    *++(yyps->ssp) = yystate;",
    "    *++(yyps->vsp) = yylval;",
    "#ifdef YYPOSN",
    "    *++(yyps->psp) = yyposn;",
    "#endif /* YYPOSN */",
    "    goto yyloop;",
    "  }",
    "  if ((yyn = yyrindex[yystate]) &&",
    "      (yyn += yychar) >= 0 &&",
    "      yyn <= YYTABLESIZE &&",
    "      yycheck[yyn] == yychar) {",
    "    yyn = yytable[yyn];",
    "    goto yyreduce;",
    "  }",
    "",
    "  /*",
    "  ** Action: error",
    "  */",
    "  if (yyps->errflag) goto yyinrecovery;",
    "  else goto yyerrlab;\t/* redundant goto to avoid 'unused label' warnings */",
    "yyerrlab:",
    "  yynewerrflag = 1;",
    "  goto yyerrhandler;",
    "yyerrquiet:",
    "  yynewerrflag = 0;",
    "yyerrhandler:",
    "  while (yyps->save) { ",
    "    int ctry; ",
    "    struct yyparsestate *save = yyps->save;",
    "#if YYDEBUG",
    "    if (yydebug)",
    "      printf(\"yydebug[%d,%d]: ERROR in state %d, CONFLICT BACKTRACKING to \"",
    "\t     \"state %d, %d tokens\\n\", (int)yydepth, yytrial!=0, yystate,",
    "\t     yyps->save->state, (int)(yylvp - yylvals - yyps->save->lexeme));",
    "#endif",
    "    /* Memorize most forward-looking error state in case",
    "     * it's really an error. */",
    "    if(yyerrctx==NULL || yyerrctx->lexeme<yylvp-yylvals) {",
    "      /* Free old saved error context state */",
    "      if(yyerrctx) YYFreeState(yyerrctx);",
    "      /* Create and fill out new saved error context state */",
    "      yyerrctx = YYNewState(yyps->ssp - yyps->ss);",
    "      yyerrctx->save = yyps->save;",
    "      yyerrctx->state = yystate;",
    "      yyerrctx->errflag = yyps->errflag;",
    "      yyerrctx->ssp = yyerrctx->ss + (yyps->ssp - yyps->ss);",
    "      yyerrctx->vsp = yyerrctx->vs + (yyps->vsp - yyps->vs);",
    "      memcpy(yyerrctx->ss, yyps->ss, (yyps->ssp - yyps->ss + 1)*sizeof(Yshort));",
    "      YYSCopy(yyerrctx->vs, yyps->vs, (yyps->ssp - yyps->ss + 1));",
    "#ifdef YYPOSN",
    "      yyerrctx->psp = yyerrctx->ps + (yyps->psp - yyps->ps);",
    "      YYPCopy(yyerrctx->ps, yyps->ps, (yyps->ssp - yyps->ss + 1));",
    "#endif /* YYPOSN */",
    "      yyerrctx->lexeme = yylvp - yylvals;",
    "    }",
    "    yychar = -1;",
    "    yylexp = yylexemes + save->lexeme;",
    "    yyps->ssp = yyps->ss + (save->ssp - save->ss);",
    "    memcpy (yyps->ss, save->ss, (yyps->ssp - yyps->ss + 1) * sizeof(Yshort));",
    "    yylvp = yylvals + save->lexeme;",
    "    yyps->vsp = yyps->vs + (save->vsp - save->vs);",
    "    YYSCopy(yyps->vs, save->vs,  yyps->vsp - yyps->vs + 1);",
    "#ifdef YYPOSN",
    "    yylpp  = yylpsns + save->lexeme;",
    "    yyps->psp = yyps->ps + (save->psp - save->ps);",
    "    YYPCopy(yyps->ps, save->ps,  yyps->psp - yyps->ps + 1);",
    "#endif /* YYPOSN */",
    "    ctry = ++save->ctry;",
    "    yystate = save->state;",
    "    /* We tried shift, try reduce now */",
    "    if ((yyn = yyctable[ctry]) >= 0) {",
    "      goto yyreduce;",
    "    }",
    "    yyps->save = save->save;",
    "    YYFreeState(save);",
    "    /*",
    "    ** Nothing left on the stack -- error",
    "    */",
    "    if (!yyps->save) {",
    "#if YYDEBUG",
    "      if (yydebug) {",
    "        printf(\"yydebug[%d]: trial parse FAILED, entering ERROR mode\\n\", ",
    "\t       yytrial!=0);",
    "      }",
    "#endif",
    "      /* Restore state as it was in the most forward-advanced error */",
    "      yylexp = yylexemes + yyerrctx->lexeme;",
    "      yychar = yylexp[-1];",
    "      yyps->ssp = yyps->ss + (yyerrctx->ssp - yyerrctx->ss);",
    "      memcpy(yyps->ss, yyerrctx->ss, (yyps->ssp - yyps->ss + 1)*sizeof(Yshort));",
    "      yylvp = yylvals   + yyerrctx->lexeme;",
    "      yylval = yylvp[-1];",
    "      yyps->vsp = yyps->vs + (yyerrctx->vsp - yyerrctx->vs);",
    "      YYSCopy(yyps->vs, yyerrctx->vs,  yyps->vsp - yyps->vs + 1);",
    "#ifdef YYPOSN",
    "      yylpp  = yylpsns   + yyerrctx->lexeme;",
    "      yyposn = yylpp[-1];",
    "      yyps->psp = yyps->ps + (yyerrctx->psp - yyerrctx->ps);",
    "      YYPCopy(yyps->ps, yyerrctx->ps,  yyps->psp - yyps->ps + 1);",
    "#endif /* YYPOSN */",
    "      yystate = yyerrctx->state;",
    "      YYFreeState(yyerrctx);",
    "      yyerrctx = NULL;",
    "    }",
    "    yynewerrflag = 1; ",
    "  }",
    "  if (yynewerrflag) {",
    "#ifdef YYERROR_DETAILED",
    "    yyerror_detailed(\"syntax error\", yychar, yylval, yyposn);",
    "#else",
    "    yyerror(\"syntax error\");",
    "#endif",
    "  }",
    "  ++yynerrs;",
    " yyinrecovery:",
    "  if (yyps->errflag < 3) {",
    "    yyps->errflag = 3;",
    "    for (;;) {",
    "      if ((yyn = yysindex[*(yyps->ssp)]) && ",
    "\t  (yyn += YYERRCODE) >= 0 &&",
    "          yyn <= YYTABLESIZE && ",
    "\t  yycheck[yyn] == YYERRCODE) {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "          printf(\"yydebug[%d,%d]: state %d, ERROR recovery shifts to state \"",
    "\t         \"%d\\n\", (int)yydepth, yytrial!=0, *(yyps->ssp), yytable[yyn]);",
    "#endif",
    "        /* Use label yyerrquiet, so that compiler does not warn */",
    "        if(yyps->errflag != yyps->errflag) goto yyerrquiet;",
    "        yystate = yytable[yyn];",
    "        goto yyshift; ",
    "      } else {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "          printf(\"yydebug[%d,%d]: ERROR recovery discards state %d\\n\",",
    "                 (int)yydepth, yytrial!=0, *(yyps->ssp));",
    "#endif",
    "        if (yyps->ssp <= yyps->ss) {",
    "\t  goto yyabort;",
    "\t}",
    "\tif(!yytrial) {",
    "\t  YYDELETEVAL(yyps->vsp[0],1);",
    "\t  YYDELETEPOSN(yyps->psp[0],1);",
    "\t}",
    "#ifdef YYDESTRUCT",
    "\tYYDESTRUCT(yytrial!=0, yyastable[yyps->ssp[0]], yyps->vsp, yyps->psp);",
    "#endif /* YYDESTRUCT */",
    "        --(yyps->ssp);",
    "        --(yyps->vsp);",
    "#ifdef YYPOSN",
    "        --(yyps->psp);",
    "#endif /* YYPOSN */",
    "      }",
    "    }",
    "  } else {",
    "    if (yychar == 0) goto yyabort;",
    "#if YYDEBUG",
    "    if (yydebug) {",
    "      yys = 0;",
    "      if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "      if (!yys) yys = \"illegal-symbol\";",
    "      printf(\"yydebug[%d,%d]: state %d, ERROR recovery discards token %d \"",
    "\t     \"(%s)\\n\", (int)yydepth, yytrial!=0, yystate, yychar, yys); ",
    "    }",
    "#endif",
    "    if(!yytrial) {",
    "      YYDELETEVAL(yylval,0);",
    "      YYDELETEPOSN(yyposn,0);",
    "    }",
    "#ifdef YYDESTRUCT",
    "    if (yychar > 0)",
    "      YYDESTRUCT(yytrial!=0, yyastable[yyttable[yychar]], &yylval, &yyposn);",
    "#endif /* YYDESTRUCT */",
    "    yychar = (-1);",
    "    goto yyloop;",
    "  }",
    "",
    "  /*",
    "  ** Reduce the rule",
    "  */",
    "yyreduce:",
    "  yym = yylen[yyn];",
    "#if YYDEBUG",
    "  if (yydebug) {",
    "    printf(\"yydebug[%d,%d]: state %d, reducing by rule %d (%s)\",",
    "           (int)yydepth, yytrial!=0, yystate, yyn, yyrule[yyn]);",
    "#ifdef YYDBPR",
    "    if (yym) {",
    "      int i;",
    "      printf(\"<\");",
    "      for (i=yym; i>0; i--) {",
    "        if (i!=yym) printf(\", \");",
    "        YYDBPR((yyps->vsp)[1-i]);",
    "      }",
    "      printf(\">\");",
    "    }",
    "#endif",
    "    printf(\"\\n\");",
    "  }",
    "#endif",
    "  if (yyps->ssp + 1 - yym >= yyps->ss + yyps->stacksize) {",
    "    YYMoreStack(yyps);",
    "  }",
    "",
    "  /* \"$$ = NULL\" default action */",
    "  memset(&yyps->val, 0, sizeof(yyps->val));",
    "",
    "#ifdef YYPOSN",
    "  /* default reduced position is NULL -- no position at all.",
    "     no position will be assigned at trial time and if no position handling",
    "     is present */",
    "  memset(&yyps->pos, 0, sizeof(yyps->pos));",
    "#ifdef YYREDUCEPOSNFUNC",
    "  reduce_posn = 1;",
    "#endif /* YYREDUCEPOSNFUNC */",
    "#endif /* YYPOSN */",
    "",
    "  switch (yyn) {",
    "",
    0
};

char *trailer[] =
{
    "#line 784 \"/home/dassat/github/cppparser/third_party/btyacc_tp/btyacc/btyaccpa.ske\"",
    "",
    "  default:",
    "    break;",
    "  }",
    "",
    "#if YYDEBUG && defined(YYDBPR)",
    "  if (yydebug) {",
    "    printf(\"yydebug[%d]: after reduction, result is \", yytrial!=0);",
    "    YYDBPR(yyps->val);",
    "    printf(\"\\n\");",
    "  }",
    "#endif",
    "",
    "#ifdef YYPOSN",
    "  /* Perform user-defined position reduction */",
    "#ifdef YYREDUCEPOSNFUNC",
    "  if(!yytrial) {",
    "    YYCALLREDUCEPOSN(YYREDUCEPOSNFUNCARG);",
    "  }",
    "#endif",
    "#endif /* YYPOSN */",
    "",
    "  yyps->ssp -= yym;",
    "  yystate = *(yyps->ssp);",
    "  yyps->vsp -= yym;",
    "#ifdef YYPOSN",
    "  yyps->psp -= yym;",
    "#endif /* YYPOSN */",
    "",
    "  yym = yylhs[yyn];",
    "  if (yystate == 0 && yym == 0) {",
    "#if YYDEBUG",
    "    if (yydebug) {",
    "      printf(\"yydebug[%d,%d]: after reduction, shifting from state 0 to state \"",
    "\t     \"%d\\n\", (int)yydepth, yytrial!=0, YYFINAL);",
    "    }",
    "#endif",
    "    yystate = YYFINAL;",
    "    *++(yyps->ssp) = YYFINAL;",
    "    *++(yyps->vsp) = yyps->val;",
    "    yyretlval = yyps->val;  /* return value of root non-terminal to yylval */",
    "#ifdef YYPOSN",
    "    *++(yyps->psp) = yyps->pos;",
    "    yyretposn = yyps->pos;  /* return value of root position to yyposn */",
    "#endif /* YYPOSN */",
    "    if (yychar < 0) {",
    "      if ((yychar = YYLex1()) < 0) {",
    "        yychar = 0;",
    "      }",
    "#if YYDEBUG",
    "      if (yydebug) {",
    "        yys = 0;",
    "        if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "        if (!yys) yys = \"illegal-symbol\";",
    "        printf(\"yydebug[%d,%d]: state %d, reading %d (%s)\\n\", ",
    "\t       (int)yydepth, yytrial!=0, YYFINAL, yychar, yys); ",
    "      }",
    "#endif",
    "    }",
    "    if (yychar == 0) goto yyaccept;",
    "    goto yyloop;",
    "  }",
    "",
    "  if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",
    "      yyn <= YYTABLESIZE && yycheck[yyn] == yystate) {",
    "    yystate = yytable[yyn];",
    "  } else {",
    "    yystate = yydgoto[yym];",
    "  }",
    "#if YYDEBUG",
    "  if (yydebug)",
    "    printf(\"yydebug[%d,%d]: after reduction, shifting from state %d to state \"",
    "\t   \"%d\\n\", (int)yydepth, yytrial!=0, *(yyps->ssp), yystate);",
    "#endif",
    "  if (yyps->ssp >= yyps->ss + yyps->stacksize - 1) {",
    "    YYMoreStack(yyps);",
    "  }",
    "  *++(yyps->ssp) = yystate;",
    "  *++(yyps->vsp) = yyps->val;",
    "#ifdef YYPOSN",
    "  *++(yyps->psp) = yyps->pos;",
    "#endif /* YYPOSN */",
    "  goto yyloop;",
    "",
    "",
    "  /*",
    "  ** Reduction declares that this path is valid.",
    "  ** Set yypath and do a full parse",
    "  */",
    "yyvalid:",
    "  if (yypath) {",
    "    goto yyabort;",
    "  }",
    "  while (yyps->save) {",
    "    struct yyparsestate *save = yyps->save;",
    "    yyps->save = save->save;",
    "    save->save = yypath;",
    "    yypath = save;",
    "  }",
    "#if YYDEBUG",
    "  if (yydebug)",
    "    printf(\"yydebug[%d,%d]: CONFLICT trial successful, backtracking to state \"",
    "\t   \"%d, %d tokens\\n\", (int)yydepth, yytrial!=0, yypath->state,",
    "\t   (int)(yylvp - yylvals - yypath->lexeme));",
    "#endif",
    "  if(yyerrctx) {",
    "    YYFreeState(yyerrctx); yyerrctx = NULL;",
    "  }",
    "  yychar = -1;",
    "  yyps->ssp = yyps->ss + (yypath->ssp - yypath->ss);",
    "  memcpy (yyps->ss, yypath->ss, (yyps->ssp - yyps->ss + 1) * sizeof(Yshort));",
    "  yylexp = yylexemes + yypath->lexeme;",
    "  yyps->vsp = yyps->vs + (yypath->vsp - yypath->vs);",
    "  YYSCopy(yyps->vs, yypath->vs,  yyps->vsp - yyps->vs + 1);",
    "  yylvp = yylvals + yypath->lexeme;",
    "#ifdef YYPOSN",
    "  yyps->psp = yyps->ps + (yypath->psp - yypath->ps);",
    "  YYPCopy(yyps->ps, yypath->ps,  yyps->psp - yyps->ps + 1);",
    "  yylpp = yylpsns + yypath->lexeme;",
    "#endif /* YYPOSN */",
    "  yystate = yypath->state;",
    "  goto yyloop;",
    "",
    "yyabort:",
    "  if(yyerrctx) {",
    "    YYFreeState(yyerrctx); yyerrctx = NULL;",
    "  }",
    "",
    "  {",
    "    YYSTYPE *pv;",
    "#ifdef YYPOSN",
    "    YYPOSN *pp = yyps->ps;",
    "#endif",
    "#ifdef YYDESTRUCT",
    "    Yshort *ps = yyps->ss;",
    "#endif",
    "    for(pv=yyps->vs; pv<yyps->vsp; pv++) {",
    "      YYDELETEVAL(*pv,2);",
    "#if defined(YYDESTRUCT)",
    "      YYDESTRUCT(yytrial!=0, yyastable[*ps++], pv, pp++);",
    "#endif /* YYDESTRUCT */",
    "    }",
    "#ifdef YYPOSN",
    "    for(pp=yyps->ps; pp<yyps->psp; pp++) {",
    "      YYDELETEPOSN(*pp,2);",
    "    }",
    "#endif /* YYPOSN */",
    "  }",
    "",
    "  while (yyps) {",
    "    struct yyparsestate *save = yyps;",
    "    yyps = save->save;",
    "    YYFreeState(save);",
    "  }",
    "  while (yypath) {",
    "    struct yyparsestate *save = yypath;",
    "    yypath = save->save;",
    "    YYFreeState(save); ",
    "  }",
    "  return (1);",
    "",
    "",
    "yyaccept:",
    "  if (yyps->save) goto yyvalid;",
    "  if(yyerrctx) {",
    "    YYFreeState(yyerrctx); yyerrctx = NULL;",
    "  }",
    "  while (yyps) {",
    "    struct yyparsestate *save = yyps;",
    "    yyps = save->save;",
    "    YYFreeState(save);",
    "  }",
    "  while (yypath) {",
    "    struct yyparsestate *save = yypath;",
    "    yypath = save->save;",
    "    YYFreeState(save); ",
    "  }",
    "  return (0);",
    "}",
    0
};

struct section section_list[] = {
	{ "banner", &banner[0] },
	{ "tables", &tables[0] },
	{ "header", &header[0] },
	{ "body", &body[0] },
	{ "trailer", &trailer[0] },
	{ 0, 0 } };
